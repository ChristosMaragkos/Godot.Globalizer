<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Godot.Globalizer.Tests/Godot.Globalizer.Tests.csproj">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Godot.Globalizer.Tests/Godot.Globalizer.Tests.csproj" />
              <option name="originalContent" value="&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;&#10;  &lt;PropertyGroup&gt;&#10;    &lt;OutputType&gt;Exe&lt;/OutputType&gt;&#10;    &lt;TargetFramework&gt;net7.0&lt;/TargetFramework&gt;&#10;    &lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;&#10;    &lt;Nullable&gt;enable&lt;/Nullable&gt;&#10;    &lt;LangVersion&gt;latest&lt;/LangVersion&gt;&#10;  &lt;/PropertyGroup&gt;&#10;  &lt;ItemGroup&gt;&#10;    &lt;ProjectReference Include=&quot;..\Godot.Globalizer\Godot.Globalizer\Godot.Globalizer.csproj&quot; OutputItemType=&quot;Analyzer&quot; ReferenceOutputAssembly=&quot;true&quot; /&gt;&#10;  &lt;/ItemGroup&gt;&#10;  &lt;ItemGroup&gt;&#10;    &lt;PackageReference Include=&quot;Microsoft.CodeAnalysis.CSharp.Workspaces&quot; Version=&quot;4.3.0&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;Microsoft.CodeAnalysis.Analyzers&quot; Version=&quot;3.3.4&quot;&gt;&#10;      &lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;&#10;    &lt;/PackageReference&gt;&#10;  &lt;/ItemGroup&gt;&#10;&lt;/Project&gt;&#10;" />
              <option name="updatedContent" value="&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;&#10;  &lt;PropertyGroup&gt;&#10;    &lt;OutputType&gt;Exe&lt;/OutputType&gt;&#10;    &lt;TargetFramework&gt;net7.0&lt;/TargetFramework&gt;&#10;    &lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;&#10;    &lt;Nullable&gt;enable&lt;/Nullable&gt;&#10;    &lt;LangVersion&gt;latest&lt;/LangVersion&gt;&#10;  &lt;/PropertyGroup&gt;&#10;  &lt;ItemGroup&gt;&#10;    &lt;ProjectReference Include=&quot;..\Godot.Globalizer\Godot.Globalizer\Godot.Globalizer.csproj&quot; OutputItemType=&quot;Analyzer&quot; ReferenceOutputAssembly=&quot;true&quot; /&gt;&#10;  &lt;/ItemGroup&gt;&#10;  &lt;ItemGroup&gt;&#10;    &lt;PackageReference Include=&quot;Microsoft.CodeAnalysis.CSharp.Workspaces&quot; Version=&quot;4.3.0&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;Microsoft.CodeAnalysis.Analyzers&quot; Version=&quot;3.3.4&quot;&gt;&#10;      &lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;&#10;    &lt;/PackageReference&gt;&#10;  &lt;/ItemGroup&gt;&#10;&lt;/Project&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Godot.Globalizer.Tests/Program.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Godot.Globalizer.Tests/Program.cs" />
              <option name="originalContent" value="using System;&#10;using System.Linq;&#10;using System.Reflection;&#10;using Microsoft.CodeAnalysis; // added&#10;using Microsoft.CodeAnalysis.CSharp; // added&#10;using Microsoft.CodeAnalysis.CodeFixes; // added&#10;using Microsoft.CodeAnalysis.Text; // added&#10;using Microsoft.CodeAnalysis.CodeActions; // for operations&#10;using Microsoft.CodeAnalysis.Editing; // potential future use&#10;using Microsoft.CodeAnalysis.CSharp.Syntax; // for ClassDeclarationSyntax&#10;&#10;// Runtime assertion harness for GlobalWrapperGenerator plus code fix validation&#10;&#10;static void Assert(bool condition, string message)&#10;{&#10;    if (!condition)&#10;    {&#10;        Console.ForegroundColor = ConsoleColor.Red;&#10;        Console.WriteLine(&quot;FAIL: &quot; + message);&#10;        Console.ResetColor();&#10;        Environment.ExitCode = 1;&#10;    }&#10;    else&#10;    {&#10;        Console.ForegroundColor = ConsoleColor.Green;&#10;        Console.WriteLine(&quot;PASS: &quot; + message);&#10;        Console.ResetColor();&#10;    }&#10;}&#10;&#10;var asm = Assembly.GetExecutingAssembly();&#10;&#10;Type? GetType(string name) =&gt; asm.GetTypes().FirstOrDefault(t =&gt; t.FullName == name);&#10;&#10;var myThing = GetType(&quot;Samples.MyThing&quot;);&#10;var myThingWrapper = GetType(&quot;Samples.MyThingGlobal&quot;);&#10;var customBase = GetType(&quot;Samples.CustomBase&quot;);&#10;var customWrapper = GetType(&quot;Samples.CustomWrapper&quot;);&#10;var anotherThing = GetType(&quot;Samples.AnotherThing&quot;);&#10;var anotherThingWrapper = GetType(&quot;Samples.AnotherThingGlobal&quot;);&#10;var plain = GetType(&quot;Samples.Plain&quot;);&#10;var plainWrapper = GetType(&quot;Samples.PlainGlobal&quot;);&#10;var blankName = GetType(&quot;Samples.BlankName&quot;);&#10;var blankNameWrapper = GetType(&quot;Samples.BlankNameGlobal&quot;);&#10;var whiteSpaceName = GetType(&quot;Samples.WhiteSpaceName&quot;);&#10;var whiteSpaceNameWrapper = GetType(&quot;Samples.WhiteSpaceNameGlobal&quot;);&#10;var genericThing = GetType(&quot;Samples.GenericThing`1&quot;);&#10;var genericThingWrapper = GetType(&quot;Samples.GenericThingGlobal&quot;);&#10;&#10;Assert(myThing != null, &quot;MyThing exists&quot;);&#10;Assert(customBase != null, &quot;CustomBase exists&quot;);&#10;Assert(anotherThing != null, &quot;AnotherThing exists&quot;);&#10;Assert(plain != null, &quot;Plain exists&quot;);&#10;Assert(blankName != null, &quot;BlankName exists&quot;);&#10;Assert(whiteSpaceName != null, &quot;WhiteSpaceName exists&quot;);&#10;Assert(genericThing != null, &quot;GenericThing&lt;T&gt; exists&quot;);&#10;&#10;// Wrapper existence expectations&#10;Assert(myThingWrapper != null, &quot;MyThingGlobal wrapper generated&quot;);&#10;Assert(customWrapper != null, &quot;CustomWrapper wrapper generated (custom name)&quot;);&#10;Assert(blankNameWrapper != null, &quot;BlankNameGlobal wrapper generated (empty string argument fallback)&quot;);&#10;Assert(whiteSpaceNameWrapper != null, &quot;WhiteSpaceNameGlobal wrapper generated (whitespace argument fallback)&quot;);&#10;// AnotherThingGlobal exists but is manual and should NOT have GlobalClass attribute&#10;Assert(anotherThingWrapper != null, &quot;AnotherThingGlobal manual wrapper present (should not be generated)&quot;);&#10;Assert(plainWrapper == null, &quot;PlainGlobal wrapper NOT generated for non-Node type&quot;);&#10;Assert(genericThingWrapper == null, &quot;GenericThingGlobal wrapper NOT generated for generic type&quot;);&#10;&#10;// Attribute + inheritance checks&#10;var globalClassAttrType = asm.GetTypes().FirstOrDefault(t =&gt; t.Name == &quot;GlobalClassAttribute&quot;);&#10;Assert(globalClassAttrType != null, &quot;GlobalClassAttribute stub present&quot;);&#10;&#10;bool HasGlobalClass(Type? t) =&gt; t != null &amp;&amp; t.GetCustomAttributes().Any(a =&gt; a.GetType() == globalClassAttrType);&#10;&#10;Assert(HasGlobalClass(myThingWrapper!), &quot;MyThingGlobal has [GlobalClass]&quot;);&#10;Assert(HasGlobalClass(customWrapper!), &quot;CustomWrapper has [GlobalClass]&quot;);&#10;Assert(HasGlobalClass(blankNameWrapper!), &quot;BlankNameGlobal has [GlobalClass]&quot;);&#10;Assert(HasGlobalClass(whiteSpaceNameWrapper!), &quot;WhiteSpaceNameGlobal has [GlobalClass]&quot;);&#10;Assert(!HasGlobalClass(anotherThingWrapper), &quot;AnotherThingGlobal does NOT have [GlobalClass] (manual, skipped generation)&quot;);&#10;&#10;Assert(myThingWrapper!.IsSubclassOf(myThing!), &quot;MyThingGlobal derives from MyThing&quot;);&#10;Assert(customWrapper!.IsSubclassOf(customBase!), &quot;CustomWrapper derives from CustomBase&quot;);&#10;Assert(blankNameWrapper!.IsSubclassOf(blankName!), &quot;BlankNameGlobal derives from BlankName&quot;);&#10;Assert(whiteSpaceNameWrapper!.IsSubclassOf(whiteSpaceName!), &quot;WhiteSpaceNameGlobal derives from WhiteSpaceName&quot;);&#10;&#10;// Code fix test for GLOB001 (add partial)&#10;try&#10;{&#10;    var code = @&quot;using Godot;\nusing Godot.Globalizer.Attributes;\n[GlobalizerWrap] public class NeedsFix : Node { }&quot;;&#10;    var tree = CSharpSyntaxTree.ParseText(code);&#10;    var root = tree.GetRoot();&#10;    var classNode = root.DescendantNodes().OfType&lt;ClassDeclarationSyntax&gt;().First(n =&gt; n.Identifier.Text == &quot;NeedsFix&quot;);&#10;    var descriptor = new DiagnosticDescriptor(&quot;GLOB001&quot;, &quot;Class must be partial&quot;, &quot;stub&quot;, &quot;Globalizer&quot;, DiagnosticSeverity.Error, true);&#10;    var diagnostic = Diagnostic.Create(descriptor, classNode.Identifier.GetLocation());&#10;    var workspace = new AdhocWorkspace();&#10;    var proj = workspace.AddProject(&quot;CodeFixProj&quot;, LanguageNames.CSharp)&#10;        .WithCompilationOptions(new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary))&#10;        .WithParseOptions(new CSharpParseOptions(LanguageVersion.Preview));&#10;    proj = proj.AddMetadataReference(MetadataReference.CreateFromFile(typeof(object).Assembly.Location));&#10;    proj = proj.AddDocument(&quot;NeedsFix.cs&quot;, code).Project;&#10;    var document = proj.Documents.First();&#10;    var provider = new Godot.Globalizer.PartialClassCodeFixProvider();&#10;    var actions = new System.Collections.Generic.List&lt;CodeAction&gt;();&#10;    var context = new CodeFixContext(document, diagnostic, (a, d) =&gt; actions.Add(a), default);&#10;    provider.RegisterCodeFixesAsync(context).GetAwaiter().GetResult();&#10;    Assert(actions.Count &gt; 0, &quot;Code fix registered for GLOB001&quot;);&#10;    var ops = actions[0].GetOperationsAsync(default).GetAwaiter().GetResult();&#10;    foreach (var op in ops)&#10;        op.Apply(workspace, default);&#10;    var newDoc = workspace.CurrentSolution.Projects.First().Documents.First();&#10;    var newText = newDoc.GetTextAsync().GetAwaiter().GetResult().ToString();&#10;    Assert(newText.Contains(&quot;partial class NeedsFix&quot;), &quot;Code fix added partial modifier&quot;);&#10;}&#10;catch (Exception ex)&#10;{&#10;    Assert(false, &quot;Code fix test failed: &quot; + ex.GetType().Name + &quot;: &quot; + ex.Message);&#10;}&#10;&#10;// --- Generator diagnostic tests ---&#10;try&#10;{&#10;    var badSources = @&quot;using Godot; using Godot.Globalizer.Attributes;\npublic class GodotObject { }\npublic class Node : GodotObject { }\n[GlobalizerWrap] class BadNotPartial : Node { }\n[GlobalizerWrap] public partial class BadGeneric&lt;T&gt; : Node { }\n[GlobalizerWrap] public partial class BadNoInheritance { }\n[GlobalizerWrap] public partial class GoodOne : Node { }&quot;;&#10;    var syntaxTree = CSharpSyntaxTree.ParseText(badSources, new CSharpParseOptions(LanguageVersion.Preview));&#10;    var refs = new[]&#10;    {&#10;        MetadataReference.CreateFromFile(typeof(object).Assembly.Location),&#10;        MetadataReference.CreateFromFile(typeof(Enumerable).Assembly.Location),&#10;        MetadataReference.CreateFromFile(typeof(Godot.Globalizer.Attributes.GlobalizerWrapAttribute).Assembly.Location)&#10;    };&#10;    var compilation = CSharpCompilation.Create(&quot;DiagTest&quot;, new[] { syntaxTree }, refs, new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));&#10;    var generator = new Godot.Globalizer.GlobalWrapperGenerator();&#10;    CSharpGeneratorDriver.Create(generator).RunGeneratorsAndUpdateCompilation(compilation, out var updated, out var diagnostics);&#10;    var allDiags = diagnostics.Concat(updated.GetDiagnostics()).ToArray();&#10;&#10;    bool Has(string id, string nameFragment) =&gt; allDiags.Any(d =&gt; d.Id == id &amp;&amp; d.GetMessage().Contains(nameFragment));&#10;&#10;    Assert(Has(&quot;GLOB001&quot;, &quot;BadNotPartial&quot;), &quot;GLOB001 reported for non-partial class&quot;);&#10;    Assert(Has(&quot;GLOB003&quot;, &quot;BadGeneric&quot;), &quot;GLOB003 reported for generic class&quot;);&#10;    Assert(Has(&quot;GLOB002&quot;, &quot;BadNoInheritance&quot;), &quot;GLOB002 reported for non-GodotObject class&quot;);&#10;    Assert(!Has(&quot;GLOB001&quot;, &quot;GoodOne&quot;), &quot;No GLOB001 for valid partial class&quot;);&#10;}&#10;catch (Exception ex)&#10;{&#10;    Assert(false, &quot;Generator diagnostic test failed: &quot; + ex.GetType().Name + &quot;: &quot; + ex.Message);&#10;}&#10;&#10;Console.WriteLine();&#10;if (Environment.ExitCode == 0)&#10;{&#10;    Console.ForegroundColor = ConsoleColor.Cyan;&#10;    Console.WriteLine(&quot;All generator + code fix assertions passed.&quot;);&#10;    Console.ResetColor();&#10;}&#10;else&#10;{&#10;    Console.ForegroundColor = ConsoleColor.Red;&#10;    Console.WriteLine(&quot;One or more assertions failed.&quot;);&#10;    Console.ResetColor();&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using System.Linq;&#10;using System.Reflection;&#10;using Microsoft.CodeAnalysis; // added&#10;using Microsoft.CodeAnalysis.CSharp; // added&#10;using Microsoft.CodeAnalysis.CodeFixes; // added&#10;using Microsoft.CodeAnalysis.Text; // added&#10;using Microsoft.CodeAnalysis.CodeActions; // for operations&#10;using Microsoft.CodeAnalysis.Editing; // potential future use&#10;using Microsoft.CodeAnalysis.CSharp.Syntax; // for ClassDeclarationSyntax&#10;&#10;// Runtime assertion harness for GlobalWrapperGenerator plus code fix validation&#10;&#10;static void Assert(bool condition, string message)&#10;{&#10;    if (!condition)&#10;    {&#10;        Console.ForegroundColor = ConsoleColor.Red;&#10;        Console.WriteLine(&quot;FAIL: &quot; + message);&#10;        Console.ResetColor();&#10;        Environment.ExitCode = 1;&#10;    }&#10;    else&#10;    {&#10;        Console.ForegroundColor = ConsoleColor.Green;&#10;        Console.WriteLine(&quot;PASS: &quot; + message);&#10;        Console.ResetColor();&#10;    }&#10;}&#10;&#10;var asm = Assembly.GetExecutingAssembly();&#10;&#10;Type? GetType(string name) =&gt; asm.GetTypes().FirstOrDefault(t =&gt; t.FullName == name);&#10;&#10;var myThing = GetType(&quot;Samples.MyThing&quot;);&#10;var myThingWrapper = GetType(&quot;Samples.MyThingGlobal&quot;);&#10;var customBase = GetType(&quot;Samples.CustomBase&quot;);&#10;var customWrapper = GetType(&quot;Samples.CustomWrapper&quot;);&#10;var anotherThing = GetType(&quot;Samples.AnotherThing&quot;);&#10;var anotherThingWrapper = GetType(&quot;Samples.AnotherThingGlobal&quot;);&#10;var plain = GetType(&quot;Samples.Plain&quot;);&#10;var plainWrapper = GetType(&quot;Samples.PlainGlobal&quot;);&#10;var blankName = GetType(&quot;Samples.BlankName&quot;);&#10;var blankNameWrapper = GetType(&quot;Samples.BlankNameGlobal&quot;);&#10;var whiteSpaceName = GetType(&quot;Samples.WhiteSpaceName&quot;);&#10;var whiteSpaceNameWrapper = GetType(&quot;Samples.WhiteSpaceNameGlobal&quot;);&#10;var genericThing = GetType(&quot;Samples.GenericThing`1&quot;);&#10;var genericThingWrapper = GetType(&quot;Samples.GenericThingGlobal&quot;);&#10;&#10;Assert(myThing != null, &quot;MyThing exists&quot;);&#10;Assert(customBase != null, &quot;CustomBase exists&quot;);&#10;Assert(anotherThing != null, &quot;AnotherThing exists&quot;);&#10;Assert(plain != null, &quot;Plain exists&quot;);&#10;Assert(blankName != null, &quot;BlankName exists&quot;);&#10;Assert(whiteSpaceName != null, &quot;WhiteSpaceName exists&quot;);&#10;Assert(genericThing != null, &quot;GenericThing&lt;T&gt; exists&quot;);&#10;&#10;// Wrapper existence expectations&#10;Assert(myThingWrapper != null, &quot;MyThingGlobal wrapper generated&quot;);&#10;Assert(customWrapper != null, &quot;CustomWrapper wrapper generated (custom name)&quot;);&#10;Assert(blankNameWrapper != null, &quot;BlankNameGlobal wrapper generated (empty string argument fallback)&quot;);&#10;Assert(whiteSpaceNameWrapper != null, &quot;WhiteSpaceNameGlobal wrapper generated (whitespace argument fallback)&quot;);&#10;// AnotherThingGlobal exists but is manual and should NOT have GlobalClass attribute&#10;Assert(anotherThingWrapper != null, &quot;AnotherThingGlobal manual wrapper present (should not be generated)&quot;);&#10;Assert(plainWrapper == null, &quot;PlainGlobal wrapper NOT generated for non-Node type&quot;);&#10;Assert(genericThingWrapper == null, &quot;GenericThingGlobal wrapper NOT generated for generic type&quot;);&#10;&#10;// Attribute + inheritance checks&#10;var globalClassAttrType = asm.GetTypes().FirstOrDefault(t =&gt; t.Name == &quot;GlobalClassAttribute&quot;);&#10;Assert(globalClassAttrType != null, &quot;GlobalClassAttribute stub present&quot;);&#10;&#10;bool HasGlobalClass(Type? t) =&gt; t != null &amp;&amp; t.GetCustomAttributes().Any(a =&gt; a.GetType() == globalClassAttrType);&#10;&#10;Assert(HasGlobalClass(myThingWrapper!), &quot;MyThingGlobal has [GlobalClass]&quot;);&#10;Assert(HasGlobalClass(customWrapper!), &quot;CustomWrapper has [GlobalClass]&quot;);&#10;Assert(HasGlobalClass(blankNameWrapper!), &quot;BlankNameGlobal has [GlobalClass]&quot;);&#10;Assert(HasGlobalClass(whiteSpaceNameWrapper!), &quot;WhiteSpaceNameGlobal has [GlobalClass]&quot;);&#10;Assert(!HasGlobalClass(anotherThingWrapper), &quot;AnotherThingGlobal does NOT have [GlobalClass] (manual, skipped generation)&quot;);&#10;&#10;Assert(myThingWrapper!.IsSubclassOf(myThing!), &quot;MyThingGlobal derives from MyThing&quot;);&#10;Assert(customWrapper!.IsSubclassOf(customBase!), &quot;CustomWrapper derives from CustomBase&quot;);&#10;Assert(blankNameWrapper!.IsSubclassOf(blankName!), &quot;BlankNameGlobal derives from BlankName&quot;);&#10;Assert(whiteSpaceNameWrapper!.IsSubclassOf(whiteSpaceName!), &quot;WhiteSpaceNameGlobal derives from WhiteSpaceName&quot;);&#10;&#10;// Code fix test for GLOB001 (add partial)&#10;try&#10;{&#10;    var code = @&quot;using Godot;\nusing Godot.Globalizer.Attributes;\n[GlobalizerWrap] public class NeedsFix : Node { }&quot;;&#10;    var tree = CSharpSyntaxTree.ParseText(code);&#10;    var root = tree.GetRoot();&#10;    var classNode = root.DescendantNodes().OfType&lt;ClassDeclarationSyntax&gt;().First(n =&gt; n.Identifier.Text == &quot;NeedsFix&quot;);&#10;    var descriptor = new DiagnosticDescriptor(&quot;GLOB001&quot;, &quot;Class must be partial&quot;, &quot;stub&quot;, &quot;Globalizer&quot;, DiagnosticSeverity.Error, true);&#10;    var diagnostic = Diagnostic.Create(descriptor, classNode.Identifier.GetLocation());&#10;    var workspace = new AdhocWorkspace();&#10;    var proj = workspace.AddProject(&quot;CodeFixProj&quot;, LanguageNames.CSharp)&#10;        .WithCompilationOptions(new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary))&#10;        .WithParseOptions(new CSharpParseOptions(LanguageVersion.Preview));&#10;    proj = proj.AddMetadataReference(MetadataReference.CreateFromFile(typeof(object).Assembly.Location));&#10;    proj = proj.AddDocument(&quot;NeedsFix.cs&quot;, code).Project;&#10;    var document = proj.Documents.First();&#10;    var provider = new Godot.Globalizer.PartialClassCodeFixProvider();&#10;    var actions = new System.Collections.Generic.List&lt;CodeAction&gt;();&#10;    var context = new CodeFixContext(document, diagnostic, (a, d) =&gt; actions.Add(a), default);&#10;    provider.RegisterCodeFixesAsync(context).GetAwaiter().GetResult();&#10;    Assert(actions.Count &gt; 0, &quot;Code fix registered for GLOB001&quot;);&#10;    var ops = actions[0].GetOperationsAsync(default).GetAwaiter().GetResult();&#10;    foreach (var op in ops)&#10;        op.Apply(workspace, default);&#10;    var newDoc = workspace.CurrentSolution.Projects.First().Documents.First();&#10;    var newText = newDoc.GetTextAsync().GetAwaiter().GetResult().ToString();&#10;    Assert(newText.Contains(&quot;partial class NeedsFix&quot;), &quot;Code fix added partial modifier&quot;);&#10;}&#10;catch (Exception ex)&#10;{&#10;    Assert(false, &quot;Code fix test failed: &quot; + ex.GetType().Name + &quot;: &quot; + ex.Message);&#10;}&#10;&#10;// --- Generator diagnostic tests ---&#10;try&#10;{&#10;    var badSources = @&quot;using Godot; using Godot.Globalizer.Attributes;\npublic class GodotObject { }\npublic class Node : GodotObject { }\n[GlobalizerWrap] class BadNotPartial : Node { }\n[GlobalizerWrap] public partial class BadGeneric&lt;T&gt; : Node { }\n[GlobalizerWrap] public partial class BadNoInheritance { }\n[GlobalizerWrap] public partial class GoodOne : Node { }&quot;;&#10;    var syntaxTree = CSharpSyntaxTree.ParseText(badSources, new CSharpParseOptions(LanguageVersion.Preview));&#10;    var refs = new[]&#10;    {&#10;        MetadataReference.CreateFromFile(typeof(object).Assembly.Location),&#10;        MetadataReference.CreateFromFile(typeof(Enumerable).Assembly.Location),&#10;        MetadataReference.CreateFromFile(typeof(Godot.Globalizer.Attributes.GlobalizerWrapAttribute).Assembly.Location)&#10;    };&#10;    var compilation = CSharpCompilation.Create(&quot;DiagTest&quot;, new[] { syntaxTree }, refs, new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));&#10;    var generator = new Godot.Globalizer.GlobalWrapperGenerator();&#10;    CSharpGeneratorDriver.Create(generator).RunGeneratorsAndUpdateCompilation(compilation, out var updated, out var diagnostics);&#10;    var allDiags = diagnostics.Concat(updated.GetDiagnostics()).ToArray();&#10;&#10;    bool Has(string id, string nameFragment) =&gt; allDiags.Any(d =&gt; d.Id == id &amp;&amp; d.GetMessage().Contains(nameFragment));&#10;&#10;    Assert(Has(&quot;GLOB001&quot;, &quot;BadNotPartial&quot;), &quot;GLOB001 reported for non-partial class&quot;);&#10;    Assert(Has(&quot;GLOB003&quot;, &quot;BadGeneric&quot;), &quot;GLOB003 reported for generic class&quot;);&#10;    Assert(Has(&quot;GLOB002&quot;, &quot;BadNoInheritance&quot;), &quot;GLOB002 reported for non-GodotObject class&quot;);&#10;    Assert(!Has(&quot;GLOB001&quot;, &quot;GoodOne&quot;), &quot;No GLOB001 for valid partial class&quot;);&#10;}&#10;catch (Exception ex)&#10;{&#10;    Assert(false, &quot;Generator diagnostic test failed: &quot; + ex.GetType().Name + &quot;: &quot; + ex.Message);&#10;}&#10;&#10;Console.WriteLine();&#10;if (Environment.ExitCode == 0)&#10;{&#10;    Console.ForegroundColor = ConsoleColor.Cyan;&#10;    Console.WriteLine(&quot;All generator + code fix assertions passed.&quot;);&#10;    Console.ResetColor();&#10;}&#10;else&#10;{&#10;    Console.ForegroundColor = ConsoleColor.Red;&#10;    Console.WriteLine(&quot;One or more assertions failed.&quot;);&#10;    Console.ResetColor();&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Godot.Globalizer.Tests/SampleClasses.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Godot.Globalizer.Tests/SampleClasses.cs" />
              <option name="originalContent" value="using Godot;&#10;using Godot.Globalizer.Attributes;&#10;&#10;namespace Samples;&#10;&#10;[GlobalizerWrap(null)]&#10;public partial class MyThing : Node { }&#10;&#10;[GlobalizerWrap(&quot;CustomWrapper&quot;)]&#10;public partial class CustomBase : Node { }&#10;&#10;[GlobalizerWrap(null)]&#10;public partial class AnotherThing : Node { }&#10;&#10;// Manual wrapper that should cause generator to skip creating a GlobalClass wrapper for AnotherThing&#10;public partial class AnotherThingGlobal : AnotherThing { }&#10;&#10;// Should NOT produce a wrapper because it doesn't derive from Godot.Node&#10;[GlobalizerWrap(null)]&#10;public partial class Plain { }&#10;&#10;// Empty custom wrapper name should fallback to BlankNameGlobal&#10;[GlobalizerWrap(&quot;&quot;)]&#10;public partial class BlankName : Node { }&#10;&#10;// Whitespace custom wrapper name should fallback to WhiteSpaceNameGlobal&#10;[GlobalizerWrap(&quot;   &quot;)]&#10;public partial class WhiteSpaceName : Node { }&#10;&#10;// Generic classes should be skipped&#10;[GlobalizerWrap(null)]&#10;public partial class GenericThing&lt;T&gt; : Node { }&#10;" />
              <option name="updatedContent" value="using Godot;&#10;using Godot.Globalizer.Attributes;&#10;&#10;namespace Samples;&#10;&#10;[GlobalizerWrap(null)]&#10;public partial class MyThing : Node { }&#10;&#10;[GlobalizerWrap(&quot;CustomWrapper&quot;)]&#10;public partial class CustomBase : Node { }&#10;&#10;[GlobalizerWrap(null)]&#10;public partial class AnotherThing : Node { }&#10;&#10;// Manual wrapper that should cause generator to skip creating a GlobalClass wrapper for AnotherThing&#10;public partial class AnotherThingGlobal : AnotherThing { }&#10;&#10;// Should NOT produce a wrapper because it doesn't derive from Godot.Node&#10;[GlobalizerWrap(null)]&#10;public partial class Plain { }&#10;&#10;// Empty custom wrapper name should fallback to BlankNameGlobal&#10;[GlobalizerWrap(&quot;&quot;)]&#10;public partial class BlankName : Node { }&#10;&#10;// Whitespace custom wrapper name should fallback to WhiteSpaceNameGlobal&#10;[GlobalizerWrap(&quot;   &quot;)]&#10;public partial class WhiteSpaceName : Node { }&#10;&#10;// Generic classes should be skipped&#10;[GlobalizerWrap(null)]&#10;public partial class GenericThing&lt;T&gt; : Node { }" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Godot.Globalizer.sln">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Godot.Globalizer.sln" />
              <option name="originalContent" value="Microsoft Visual Studio Solution File, Format Version 12.00&#10;Project(&quot;{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&quot;) = &quot;Godot.Globalizer&quot;, &quot;Godot.Globalizer\Godot.Globalizer\Godot.Globalizer.csproj&quot;, &quot;{B0A3AD18-6BC3-416B-9472-7606623367EA}&quot;&#10;EndProject&#10;Project(&quot;{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&quot;) = &quot;Godot.Globalizer.Tests&quot;, &quot;Godot.Globalizer.Tests\Godot.Globalizer.Tests.csproj&quot;, &quot;{2A2813D7-F737-429E-B7F5-DCE39CAF22BD}&quot;&#10;EndProject&#10;Project(&quot;{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&quot;) = &quot;Godot.Globalizer.Abstractions&quot;, &quot;Godot.Globalizer.Abstractions\Godot.Globalizer.Abstractions.csproj&quot;, &quot;{7A4F0C38-5F6A-4C2B-A7E4-6E1AF4D7B9F2}&quot;&#10;EndProject&#10;Global&#10;&#9;GlobalSection(SolutionConfigurationPlatforms) = preSolution&#10;&#9;&#9;Debug|Any CPU = Debug|Any CPU&#10;&#9;&#9;Release|Any CPU = Release|Any CPU&#10;&#9;EndGlobalSection&#10;&#9;GlobalSection(ProjectConfigurationPlatforms) = postSolution&#10;&#9;&#9;{B0A3AD18-6BC3-416B-9472-7606623367EA}.Debug|Any CPU.ActiveCfg = Debug|Any CPU&#10;&#9;&#9;{B0A3AD18-6BC3-416B-9472-7606623367EA}.Debug|Any CPU.Build.0 = Debug|Any CPU&#10;&#9;&#9;{B0A3AD18-6BC3-416B-9472-7606623367EA}.Release|Any CPU.ActiveCfg = Release|Any CPU&#10;&#9;&#9;{B0A3AD18-6BC3-416B-9472-7606623367EA}.Release|Any CPU.Build.0 = Release|Any CPU&#10;&#9;&#9;{2A2813D7-F737-429E-B7F5-DCE39CAF22BD}.Debug|Any CPU.ActiveCfg = Debug|Any CPU&#10;&#9;&#9;{2A2813D7-F737-429E-B7F5-DCE39CAF22BD}.Debug|Any CPU.Build.0 = Debug|Any CPU&#10;&#9;&#9;{2A2813D7-F737-429E-B7F5-DCE39CAF22BD}.Release|Any CPU.ActiveCfg = Release|Any CPU&#10;&#9;&#9;{2A2813D7-F737-429E-B7F5-DCE39CAF22BD}.Release|Any CPU.Build.0 = Release|Any CPU&#10;&#9;&#9;{7A4F0C38-5F6A-4C2B-A7E4-6E1AF4D7B9F2}.Debug|Any CPU.ActiveCfg = Debug|Any CPU&#10;&#9;&#9;{7A4F0C38-5F6A-4C2B-A7E4-6E1AF4D7B9F2}.Debug|Any CPU.Build.0 = Debug|Any CPU&#10;&#9;&#9;{7A4F0C38-5F6A-4C2B-A7E4-6E1AF4D7B9F2}.Release|Any CPU.ActiveCfg = Release|Any CPU&#10;&#9;&#9;{7A4F0C38-5F6A-4C2B-A7E4-6E1AF4D7B9F2}.Release|Any CPU.Build.0 = Release|Any CPU&#10;&#9;EndGlobalSection&#10;EndGlobal&#10;" />
              <option name="updatedContent" value="Microsoft Visual Studio Solution File, Format Version 12.00&#10;Project(&quot;{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&quot;) = &quot;Godot.Globalizer&quot;, &quot;Godot.Globalizer\Godot.Globalizer\Godot.Globalizer.csproj&quot;, &quot;{B0A3AD18-6BC3-416B-9472-7606623367EA}&quot;&#10;EndProject&#10;Project(&quot;{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&quot;) = &quot;Godot.Globalizer.Tests&quot;, &quot;Godot.Globalizer.Tests\Godot.Globalizer.Tests.csproj&quot;, &quot;{2A2813D7-F737-429E-B7F5-DCE39CAF22BD}&quot;&#10;EndProject&#10;Project(&quot;{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}&quot;) = &quot;Godot.Globalizer.Abstractions&quot;, &quot;Godot.Globalizer.Abstractions\Godot.Globalizer.Abstractions.csproj&quot;, &quot;{7A4F0C38-5F6A-4C2B-A7E4-6E1AF4D7B9F2}&quot;&#10;EndProject&#10;Global&#10;&#9;GlobalSection(SolutionConfigurationPlatforms) = preSolution&#10;&#9;&#9;Debug|Any CPU = Debug|Any CPU&#10;&#9;&#9;Release|Any CPU = Release|Any CPU&#10;&#9;EndGlobalSection&#10;&#9;GlobalSection(ProjectConfigurationPlatforms) = postSolution&#10;&#9;&#9;{B0A3AD18-6BC3-416B-9472-7606623367EA}.Debug|Any CPU.ActiveCfg = Debug|Any CPU&#10;&#9;&#9;{B0A3AD18-6BC3-416B-9472-7606623367EA}.Debug|Any CPU.Build.0 = Debug|Any CPU&#10;&#9;&#9;{B0A3AD18-6BC3-416B-9472-7606623367EA}.Release|Any CPU.ActiveCfg = Release|Any CPU&#10;&#9;&#9;{B0A3AD18-6BC3-416B-9472-7606623367EA}.Release|Any CPU.Build.0 = Release|Any CPU&#10;&#9;&#9;{2A2813D7-F737-429E-B7F5-DCE39CAF22BD}.Debug|Any CPU.ActiveCfg = Debug|Any CPU&#10;&#9;&#9;{2A2813D7-F737-429E-B7F5-DCE39CAF22BD}.Debug|Any CPU.Build.0 = Debug|Any CPU&#10;&#9;&#9;{2A2813D7-F737-429E-B7F5-DCE39CAF22BD}.Release|Any CPU.ActiveCfg = Release|Any CPU&#10;&#9;&#9;{2A2813D7-F737-429E-B7F5-DCE39CAF22BD}.Release|Any CPU.Build.0 = Release|Any CPU&#10;&#9;&#9;{7A4F0C38-5F6A-4C2B-A7E4-6E1AF4D7B9F2}.Debug|Any CPU.ActiveCfg = Debug|Any CPU&#10;&#9;&#9;{7A4F0C38-5F6A-4C2B-A7E4-6E1AF4D7B9F2}.Debug|Any CPU.Build.0 = Debug|Any CPU&#10;&#9;&#9;{7A4F0C38-5F6A-4C2B-A7E4-6E1AF4D7B9F2}.Release|Any CPU.ActiveCfg = Release|Any CPU&#10;&#9;&#9;{7A4F0C38-5F6A-4C2B-A7E4-6E1AF4D7B9F2}.Release|Any CPU.Build.0 = Release|Any CPU&#10;&#9;EndGlobalSection&#10;EndGlobal" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Godot.Globalizer/Godot.Globalizer/GlobalWrapperGenerator.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Godot.Globalizer/Godot.Globalizer/GlobalWrapperGenerator.cs" />
              <option name="originalContent" value="using System.Linq;&#10;using System.Text;&#10;using Microsoft.CodeAnalysis;&#10;using Microsoft.CodeAnalysis.CSharp;&#10;using Microsoft.CodeAnalysis.CSharp.Syntax;&#10;&#10;namespace Godot.Globalizer;&#10;&#10;[Generator]&#10;public sealed class GlobalWrapperGenerator : IIncrementalGenerator&#10;{&#10;    private const string AttributeName = &quot;GlobalizerWrap&quot;;&#10;    private const string AttributeFullName = &quot;Godot.Globalizer.Attributes.GlobalizerWrapAttribute&quot;;&#10;&#10;    public void Initialize(IncrementalGeneratorInitializationContext context)&#10;    {&#10;        var candidates = context.SyntaxProvider.CreateSyntaxProvider(&#10;            static (n, _) =&gt; n is ClassDeclarationSyntax { AttributeLists.Count: &gt; 0 },&#10;            static (ctx, _) =&gt;&#10;            {&#10;                var cds = (ClassDeclarationSyntax)ctx.Node;&#10;                return cds.AttributeLists.Any(l =&gt; l.Attributes.Any(a =&gt; a.Name.ToString().Contains(AttributeName)))&#10;                    ? cds&#10;                    : null;&#10;            }).Where(static c =&gt; c is not null);&#10;&#10;        var combo = context.CompilationProvider.Combine(candidates.Collect());&#10;&#10;        context.RegisterSourceOutput(combo,&#10;            static (spc, pair) =&gt;&#10;            {&#10;                var (compilation, list) = pair;&#10;                if (list.Length == 0) return;&#10;&#10;                var attrSymbol = compilation.GetTypeByMetadataName(AttributeFullName);&#10;                var nodeSymbol = compilation.GetTypeByMetadataName(&quot;Godot.Node&quot;);&#10;                var godotObjectSymbol = compilation.GetTypeByMetadataName(&quot;Godot.GodotObject&quot;);&#10;                var globalClassAttr = compilation.GetTypeByMetadataName(&quot;Godot.GlobalClassAttribute&quot;);&#10;&#10;                foreach (var cds in list)&#10;                {&#10;                    spc.CancellationToken.ThrowIfCancellationRequested();&#10;                    Generate(spc, compilation, cds!, attrSymbol, nodeSymbol, godotObjectSymbol, globalClassAttr);&#10;                }&#10;            });&#10;    }&#10;&#10;    private static void Generate(SourceProductionContext ctx,&#10;        Compilation compilation,&#10;        ClassDeclarationSyntax cds,&#10;        INamedTypeSymbol? attrSymbol,&#10;        INamedTypeSymbol? nodeSymbol,&#10;        INamedTypeSymbol? godotObjectSymbol,&#10;        INamedTypeSymbol? globalClassAttr)&#10;    {&#10;        if (attrSymbol is null) return;&#10;        var model = compilation.GetSemanticModel(cds.SyntaxTree);&#10;        if (model.GetDeclaredSymbol(cds) is not INamedTypeSymbol sym) return;&#10;&#10;        var attrData = sym.GetAttributes().FirstOrDefault(a =&gt; SymbolEqualityComparer.Default.Equals(a.AttributeClass, attrSymbol));&#10;        if (attrData is null) return; // Not actually annotated (name match false positive)&#10;&#10;        // Enforce: class must be partial&#10;        if (!cds.Modifiers.Any(m =&gt; m.IsKind(SyntaxKind.PartialKeyword)))&#10;        {&#10;            ctx.ReportDiagnostic(Diagnostic.Create(Diagnostics.MustBePartial, cds.Identifier.GetLocation(), sym.Name));&#10;            return;&#10;        }&#10;&#10;        // Enforce: class must be non-generic&#10;        if (sym.IsGenericType)&#10;        {&#10;            ctx.ReportDiagnostic(Diagnostic.Create(Diagnostics.MustBeNonGeneric, cds.Identifier.GetLocation(), sym.Name));&#10;            return;&#10;        }&#10;&#10;        // Enforce: must inherit from Godot.GodotObject (directly or indirectly)&#10;        if (godotObjectSymbol is not null &amp;&amp; !DerivesOrEquals(sym, godotObjectSymbol))&#10;        {&#10;            ctx.ReportDiagnostic(Diagnostic.Create(Diagnostics.MustInheritGodotObject, cds.Identifier.GetLocation(), sym.Name));&#10;            return;&#10;        }&#10;&#10;        // Accept only classes that (optionally) derive from Node (for wrapper emission). If not Node-derived but still GodotObject-derived, we can still wrap? Keep existing Node constraint.&#10;        if (nodeSymbol is not null &amp;&amp; !DerivesOrEquals(sym, nodeSymbol))&#10;        {&#10;            // Currently we choose not to emit a wrapper for non-Node GodotObjects.&#10;            return;&#10;        }&#10;&#10;        string? custom = null;&#10;        var providedNameValid = false;&#10;        if (attrData.ConstructorArguments.Length == 1 &amp;&amp; attrData.ConstructorArguments[0].Value is string s)&#10;        {&#10;            if (!string.IsNullOrWhiteSpace(s))&#10;            {&#10;                custom = s.Trim();&#10;                providedNameValid = true;&#10;            }&#10;        }&#10;&#10;        var wrapperName = custom ?? sym.Name + &quot;Global&quot;;&#10;        if (!providedNameValid &amp;&amp; attrData.ConstructorArguments.Length == 1)&#10;        {&#10;            // Provided but empty/whitespace -&gt; sanitized fallback&#10;            ctx.ReportDiagnostic(Diagnostic.Create(Diagnostics.WrapperNameSanitized, cds.Identifier.GetLocation(), wrapperName));&#10;        }&#10;&#10;        // Name collision check within namespace&#10;        if (sym.ContainingNamespace.GetTypeMembers(wrapperName).Any())&#10;        {&#10;            ctx.ReportDiagnostic(Diagnostic.Create(Diagnostics.WrapperNameCollision, cds.Identifier.GetLocation(), wrapperName, sym.Name));&#10;            return;&#10;        }&#10;&#10;        var ns = sym.ContainingNamespace.IsGlobalNamespace ? null : sym.ContainingNamespace.ToDisplayString();&#10;        var baseType = sym.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);&#10;        var sb = new StringBuilder();&#10;        sb.AppendLine(&quot;// &lt;auto-generated/&gt;&quot;);&#10;        sb.AppendLine(&quot;using Godot;&quot;);&#10;        if (ns is not null) sb.Append(&quot;namespace &quot;).Append(ns).AppendLine(&quot;;&quot;).AppendLine();&#10;        if (globalClassAttr is not null) sb.AppendLine(&quot;[GlobalClass]&quot;);&#10;        sb.Append(&quot;public partial class &quot;).Append(wrapperName).Append(&quot; : &quot;).Append(baseType).AppendLine();&#10;        sb.AppendLine(&quot;{&quot;);&#10;        sb.Append(&quot;    public static &quot;).Append(wrapperName).Append(&quot; Create() =&gt; new &quot;).Append(wrapperName).Append(&quot;();&quot;);&#10;        sb.AppendLine();&#10;        sb.AppendLine(&quot;}&quot;);&#10;        ctx.AddSource(wrapperName + &quot;.g.cs&quot;, sb.ToString());&#10;    }&#10;&#10;    private static bool DerivesOrEquals(INamedTypeSymbol t, INamedTypeSymbol baseType)&#10;    {&#10;        if (SymbolEqualityComparer.Default.Equals(t, baseType)) return true;&#10;        for (var cur = t.BaseType; cur is not null; cur = cur.BaseType)&#10;            if (SymbolEqualityComparer.Default.Equals(cur, baseType)) return true;&#10;        return false;&#10;    }&#10;}" />
              <option name="updatedContent" value="using System.Linq;&#10;using System.Text;&#10;using Microsoft.CodeAnalysis;&#10;using Microsoft.CodeAnalysis.CSharp;&#10;using Microsoft.CodeAnalysis.CSharp.Syntax;&#10;&#10;namespace Godot.Globalizer;&#10;&#10;[Generator]&#10;public sealed class GlobalWrapperGenerator : IIncrementalGenerator&#10;{&#10;    private const string AttributeName = &quot;GlobalizerWrap&quot;;&#10;    private const string AttributeFullName = &quot;Godot.Globalizer.Attributes.GlobalizerWrapAttribute&quot;;&#10;&#10;    public void Initialize(IncrementalGeneratorInitializationContext context)&#10;    {&#10;        var candidates = context.SyntaxProvider.CreateSyntaxProvider(&#10;            static (n, _) =&gt; n is ClassDeclarationSyntax { AttributeLists.Count: &gt; 0 },&#10;            static (ctx, _) =&gt;&#10;            {&#10;                var cds = (ClassDeclarationSyntax)ctx.Node;&#10;                return cds.AttributeLists.Any(l =&gt; l.Attributes.Any(a =&gt; a.Name.ToString().Contains(AttributeName)))&#10;                    ? cds&#10;                    : null;&#10;            }).Where(static c =&gt; c is not null);&#10;&#10;        var combo = context.CompilationProvider.Combine(candidates.Collect());&#10;&#10;        context.RegisterSourceOutput(combo,&#10;            static (spc, pair) =&gt;&#10;            {&#10;                var (compilation, list) = pair;&#10;                if (list.Length == 0) return;&#10;&#10;                var attrSymbol = compilation.GetTypeByMetadataName(AttributeFullName);&#10;                var nodeSymbol = compilation.GetTypeByMetadataName(&quot;Godot.Node&quot;);&#10;                var godotObjectSymbol = compilation.GetTypeByMetadataName(&quot;Godot.GodotObject&quot;);&#10;                var globalClassAttr = compilation.GetTypeByMetadataName(&quot;Godot.GlobalClassAttribute&quot;);&#10;&#10;                foreach (var cds in list)&#10;                {&#10;                    spc.CancellationToken.ThrowIfCancellationRequested();&#10;                    Generate(spc, compilation, cds!, attrSymbol, nodeSymbol, godotObjectSymbol, globalClassAttr);&#10;                }&#10;            });&#10;    }&#10;&#10;    private static void Generate(SourceProductionContext ctx,&#10;        Compilation compilation,&#10;        ClassDeclarationSyntax cds,&#10;        INamedTypeSymbol? attrSymbol,&#10;        INamedTypeSymbol? nodeSymbol,&#10;        INamedTypeSymbol? godotObjectSymbol,&#10;        INamedTypeSymbol? globalClassAttr)&#10;    {&#10;        if (attrSymbol is null) return;&#10;        var model = compilation.GetSemanticModel(cds.SyntaxTree);&#10;        if (model.GetDeclaredSymbol(cds) is not INamedTypeSymbol sym) return;&#10;&#10;        var attrData = sym.GetAttributes().FirstOrDefault(a =&gt; SymbolEqualityComparer.Default.Equals(a.AttributeClass, attrSymbol));&#10;        if (attrData is null) return; // Not actually annotated (name match false positive)&#10;&#10;        // Enforce: class must be partial&#10;        if (!cds.Modifiers.Any(m =&gt; m.IsKind(SyntaxKind.PartialKeyword)))&#10;        {&#10;            ctx.ReportDiagnostic(Diagnostic.Create(Diagnostics.MustBePartial, cds.Identifier.GetLocation(), sym.Name));&#10;            return;&#10;        }&#10;&#10;        // Enforce: class must be non-generic&#10;        if (sym.IsGenericType)&#10;        {&#10;            ctx.ReportDiagnostic(Diagnostic.Create(Diagnostics.MustBeNonGeneric, cds.Identifier.GetLocation(), sym.Name));&#10;            return;&#10;        }&#10;&#10;        // Enforce: must inherit from Godot.GodotObject (directly or indirectly)&#10;        if (godotObjectSymbol is not null &amp;&amp; !DerivesOrEquals(sym, godotObjectSymbol))&#10;        {&#10;            ctx.ReportDiagnostic(Diagnostic.Create(Diagnostics.MustInheritGodotObject, cds.Identifier.GetLocation(), sym.Name));&#10;            return;&#10;        }&#10;&#10;        // Accept only classes that (optionally) derive from Node (for wrapper emission). If not Node-derived but still GodotObject-derived, we can still wrap? Keep existing Node constraint.&#10;        if (nodeSymbol is not null &amp;&amp; !DerivesOrEquals(sym, nodeSymbol))&#10;        {&#10;            // Currently we choose not to emit a wrapper for non-Node GodotObjects.&#10;            return;&#10;        }&#10;&#10;        string? custom = null;&#10;        var providedNameValid = false;&#10;        if (attrData.ConstructorArguments.Length == 1 &amp;&amp; attrData.ConstructorArguments[0].Value is string s)&#10;        {&#10;            if (!string.IsNullOrWhiteSpace(s))&#10;            {&#10;                custom = s.Trim();&#10;                providedNameValid = true;&#10;            }&#10;        }&#10;&#10;        var wrapperName = custom ?? sym.Name + &quot;Global&quot;;&#10;        if (!providedNameValid &amp;&amp; attrData.ConstructorArguments.Length == 1)&#10;        {&#10;            // Provided but empty/whitespace -&gt; sanitized fallback&#10;            ctx.ReportDiagnostic(Diagnostic.Create(Diagnostics.WrapperNameSanitized, cds.Identifier.GetLocation(), wrapperName));&#10;        }&#10;&#10;        // Name collision check within namespace&#10;        if (sym.ContainingNamespace.GetTypeMembers(wrapperName).Any())&#10;        {&#10;            ctx.ReportDiagnostic(Diagnostic.Create(Diagnostics.WrapperNameCollision, cds.Identifier.GetLocation(), wrapperName, sym.Name));&#10;            return;&#10;        }&#10;&#10;        var ns = sym.ContainingNamespace.IsGlobalNamespace ? null : sym.ContainingNamespace.ToDisplayString();&#10;        var baseType = sym.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);&#10;        var sb = new StringBuilder();&#10;        sb.AppendLine(&quot;// &lt;auto-generated/&gt;&quot;);&#10;        sb.AppendLine(&quot;using Godot;&quot;);&#10;        if (ns is not null) sb.Append(&quot;namespace &quot;).Append(ns).AppendLine(&quot;;&quot;).AppendLine();&#10;        if (globalClassAttr is not null) sb.AppendLine(&quot;[GlobalClass]&quot;);&#10;        sb.Append(&quot;public partial class &quot;).Append(wrapperName).Append(&quot; : &quot;).Append(baseType).AppendLine();&#10;        sb.AppendLine(&quot;{&quot;);&#10;        sb.Append(&quot;    public static &quot;).Append(wrapperName).Append(&quot; Create() =&gt; new &quot;).Append(wrapperName).Append(&quot;();&quot;);&#10;        sb.AppendLine();&#10;        sb.AppendLine(&quot;}&quot;);&#10;        ctx.AddSource(wrapperName + &quot;.g.cs&quot;, sb.ToString());&#10;    }&#10;&#10;    private static bool DerivesOrEquals(INamedTypeSymbol t, INamedTypeSymbol baseType)&#10;    {&#10;        if (SymbolEqualityComparer.Default.Equals(t, baseType)) return true;&#10;        for (var cur = t.BaseType; cur is not null; cur = cur.BaseType)&#10;            if (SymbolEqualityComparer.Default.Equals(cur, baseType)) return true;&#10;        return false;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Godot.Globalizer/Godot.Globalizer/Godot.Globalizer.csproj">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Godot.Globalizer/Godot.Globalizer/Godot.Globalizer.csproj" />
              <option name="originalContent" value="&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;&#10;&#10;    &lt;PropertyGroup&gt;&#10;        &lt;TargetFramework&gt;netstandard2.0&lt;/TargetFramework&gt;&#10;        &lt;Nullable&gt;enable&lt;/Nullable&gt;&#10;        &lt;LangVersion&gt;latest&lt;/LangVersion&gt;&#10;        &lt;EnforceExtendedAnalyzerRules&gt;true&lt;/EnforceExtendedAnalyzerRules&gt;&#10;        &lt;IsRoslynComponent&gt;true&lt;/IsRoslynComponent&gt;&#10;        &lt;RootNamespace&gt;Godot.Globalizer&lt;/RootNamespace&gt;&#10;        &lt;PackageId&gt;Godot.Globalizer&lt;/PackageId&gt;&#10;        &lt;Version&gt;0.1.0&lt;/Version&gt;&#10;        &lt;Authors&gt;YourName&lt;/Authors&gt;&#10;        &lt;Description&gt;Source generator that creates [GlobalClass] Godot wrapper nodes for classes annotated with [GlobalizerWrap].&lt;/Description&gt;&#10;        &lt;PackageLicenseExpression&gt;MIT&lt;/PackageLicenseExpression&gt;&#10;        &lt;RepositoryUrl&gt;https://example.com/yourrepo&lt;/RepositoryUrl&gt;&#10;        &lt;PackageReadmeFile&gt;Readme.md&lt;/PackageReadmeFile&gt;&#10;        &lt;PublishRepositoryUrl&gt;true&lt;/PublishRepositoryUrl&gt;&#10;        &lt;EmbedUntrackedSources&gt;true&lt;/EmbedUntrackedSources&gt;&#10;        &lt;IncludeSymbols&gt;true&lt;/IncludeSymbols&gt;&#10;        &lt;SymbolPackageFormat&gt;snupkg&lt;/SymbolPackageFormat&gt;&#10;        &lt;GeneratePackageOnBuild&gt;true&lt;/GeneratePackageOnBuild&gt;&#10;        &lt;PackageType&gt;Analyzer&lt;/PackageType&gt;&#10;        &lt;IsPackable&gt;true&lt;/IsPackable&gt;&#10;        &lt;PackageTags&gt;Godot;SourceGenerator;Analyzer;GlobalClass;Wrapper&lt;/PackageTags&gt;&#10;    &lt;/PropertyGroup&gt;&#10;&#10;    &lt;ItemGroup&gt;&#10;        &lt;None Include=&quot;Readme.md&quot; Pack=&quot;true&quot; PackagePath=&quot;/&quot; /&gt;&#10;    &lt;/ItemGroup&gt;&#10;&#10;    &lt;ItemGroup&gt;&#10;        &lt;PackageReference Include=&quot;Microsoft.CodeAnalysis.Analyzers&quot; Version=&quot;3.3.4&quot;&gt;&#10;            &lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;&#10;            &lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;&#10;        &lt;/PackageReference&gt;&#10;        &lt;PackageReference Include=&quot;Microsoft.CodeAnalysis.CSharp&quot; Version=&quot;4.3.0&quot; /&gt;&#10;        &lt;PackageReference Include=&quot;Microsoft.CodeAnalysis.CSharp.Workspaces&quot; Version=&quot;4.3.0&quot; /&gt;&#10;        &lt;PackageReference Include=&quot;Microsoft.SourceLink.GitHub&quot; Version=&quot;8.0.0&quot; PrivateAssets=&quot;All&quot; /&gt;&#10;    &lt;/ItemGroup&gt;&#10;&#10;    &lt;ItemGroup&gt;&#10;      &lt;Folder Include=&quot;Properties\&quot; /&gt;&#10;    &lt;/ItemGroup&gt;&#10;&#10;    &lt;ItemGroup&gt;&#10;      &lt;ProjectReference Include=&quot;..\..\Godot.Globalizer.Abstractions\Godot.Globalizer.Abstractions.csproj&quot; /&gt;&#10;    &lt;/ItemGroup&gt;&#10;&#10;&lt;/Project&gt;&#10;" />
              <option name="updatedContent" value="&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;&#10;&#10;    &lt;PropertyGroup&gt;&#10;        &lt;TargetFramework&gt;netstandard2.0&lt;/TargetFramework&gt;&#10;        &lt;Nullable&gt;enable&lt;/Nullable&gt;&#10;        &lt;LangVersion&gt;latest&lt;/LangVersion&gt;&#10;        &lt;EnforceExtendedAnalyzerRules&gt;true&lt;/EnforceExtendedAnalyzerRules&gt;&#10;        &lt;IsRoslynComponent&gt;true&lt;/IsRoslynComponent&gt;&#10;        &lt;RootNamespace&gt;Godot.Globalizer&lt;/RootNamespace&gt;&#10;        &lt;PackageId&gt;Godot.Globalizer&lt;/PackageId&gt;&#10;        &lt;Version&gt;0.1.0&lt;/Version&gt;&#10;        &lt;Authors&gt;YourName&lt;/Authors&gt;&#10;        &lt;Description&gt;Source generator that creates [GlobalClass] Godot wrapper nodes for classes annotated with [GlobalizerWrap].&lt;/Description&gt;&#10;        &lt;PackageLicenseExpression&gt;MIT&lt;/PackageLicenseExpression&gt;&#10;        &lt;RepositoryUrl&gt;https://example.com/yourrepo&lt;/RepositoryUrl&gt;&#10;        &lt;PackageReadmeFile&gt;Readme.md&lt;/PackageReadmeFile&gt;&#10;        &lt;PublishRepositoryUrl&gt;true&lt;/PublishRepositoryUrl&gt;&#10;        &lt;EmbedUntrackedSources&gt;true&lt;/EmbedUntrackedSources&gt;&#10;        &lt;IncludeSymbols&gt;true&lt;/IncludeSymbols&gt;&#10;        &lt;SymbolPackageFormat&gt;snupkg&lt;/SymbolPackageFormat&gt;&#10;        &lt;GeneratePackageOnBuild&gt;true&lt;/GeneratePackageOnBuild&gt;&#10;        &lt;PackageType&gt;Analyzer&lt;/PackageType&gt;&#10;        &lt;IsPackable&gt;true&lt;/IsPackable&gt;&#10;        &lt;PackageTags&gt;Godot;SourceGenerator;Analyzer;GlobalClass;Wrapper&lt;/PackageTags&gt;&#10;    &lt;/PropertyGroup&gt;&#10;&#10;    &lt;ItemGroup&gt;&#10;        &lt;None Include=&quot;Readme.md&quot; Pack=&quot;true&quot; PackagePath=&quot;/&quot; /&gt;&#10;    &lt;/ItemGroup&gt;&#10;&#10;    &lt;ItemGroup&gt;&#10;        &lt;PackageReference Include=&quot;Microsoft.CodeAnalysis.Analyzers&quot; Version=&quot;3.3.4&quot;&gt;&#10;            &lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;&#10;            &lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;&#10;        &lt;/PackageReference&gt;&#10;        &lt;PackageReference Include=&quot;Microsoft.CodeAnalysis.CSharp&quot; Version=&quot;4.3.0&quot; /&gt;&#10;        &lt;PackageReference Include=&quot;Microsoft.CodeAnalysis.CSharp.Workspaces&quot; Version=&quot;4.3.0&quot; /&gt;&#10;        &lt;PackageReference Include=&quot;Microsoft.SourceLink.GitHub&quot; Version=&quot;8.0.0&quot; PrivateAssets=&quot;All&quot; /&gt;&#10;    &lt;/ItemGroup&gt;&#10;&#10;    &lt;ItemGroup&gt;&#10;      &lt;Folder Include=&quot;Properties\&quot; /&gt;&#10;    &lt;/ItemGroup&gt;&#10;&#10;    &lt;ItemGroup&gt;&#10;      &lt;ProjectReference Include=&quot;..\..\Godot.Globalizer.Abstractions\Godot.Globalizer.Abstractions.csproj&quot; /&gt;&#10;    &lt;/ItemGroup&gt;&#10;&#10;&lt;/Project&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>