using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;

namespace Godot.Globalizer;

[Generator]
public sealed class GlobalWrapperGenerator : IIncrementalGenerator
{
    private const string AttributeFullName = "Godot.Globalizer.Attributes.GlobalizerWrapAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var metaData = context.CompilationProvider.Select(static (compilation, _) =>
        {
            var attr = compilation.GetTypeByMetadataName(AttributeFullName);
            if (attr is null) return (compilation, ImmutableArray<INamedTypeSymbol>.Empty);

            var builder = ImmutableArray.CreateBuilder<INamedTypeSymbol>();

            Walk(compilation.GlobalNamespace);
            return (compilation, builder.ToImmutable());

            void Walk(INamespaceSymbol ns)
            {
                foreach (var t in ns.GetTypeMembers()
                             .Where(t => t.DeclaringSyntaxReferences.Length == 0)
                             .Where(t => t.GetAttributes()
                                 .Any(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, attr))))
                {
                    builder.Add(t);
                }

                foreach (var child in ns.GetNamespaceMembers())
                    Walk(child);
            }
        });

        context.RegisterSourceOutput(metaData, static (spc, tuple) =>
        {
            var (compilation, candidates) = tuple;

            if (candidates.IsDefaultOrEmpty) return;

            var nodeSymbol = compilation.GetTypeByMetadataName("Godot.Node");
            var godotObjectSymbol = compilation.GetTypeByMetadataName("Godot.GodotObject");
            var attrSymbol = compilation.GetTypeByMetadataName(AttributeFullName);
            var globalClassAttr = compilation.GetTypeByMetadataName("Godot.GlobalClassAttribute");

            if (attrSymbol is null || nodeSymbol is null || godotObjectSymbol is null || globalClassAttr is null)
                return;

            foreach (var sym in candidates)
            {
                spc.CancellationToken.ThrowIfCancellationRequested();

                if (sym.IsGenericType) continue;
                if (!DerivesOrEquals(sym, godotObjectSymbol)) continue;
                if (!DerivesOrEquals(sym, nodeSymbol)) continue;

                var attrData = sym.GetAttributes()
                    .FirstOrDefault(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, attrSymbol));
                if (attrData is null) continue;

                string? provided = null;
                if (attrData.ConstructorArguments.Length == 1 &&
                    attrData.ConstructorArguments[0].Value is string s &&
                    !string.IsNullOrWhiteSpace(s))
                    provided = s.Trim();

                var wrapperName = provided ?? sym.Name + "Global";

                // Skip if a type with the wrapper name already exists in that namespace (avoid duplicates)
                if (sym.ContainingNamespace.GetTypeMembers(wrapperName).Any())
                    continue;

                EmitWrapper(spc, sym, wrapperName);
            }
        });
    }

    private static void EmitWrapper(SourceProductionContext ctx,
        INamedTypeSymbol baseSymbol,
        string wrapperName)
    {
        var alreadyExists = baseSymbol.ContainingNamespace.GetTypeMembers(wrapperName).Any();
        if (alreadyExists) return;
        
        var ns = baseSymbol.ContainingNamespace.IsGlobalNamespace
            ? null
            : baseSymbol.ContainingNamespace.ToDisplayString();

        // Use simple name since wrapper is placed in same namespace
        var baseTypeName = baseSymbol.Name;
        if (baseSymbol.TypeArguments.Length > 0)
            baseTypeName = baseSymbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);
        
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using Godot;");
        if (ns is not null)
        {
            sb.Append("namespace ").Append(ns).AppendLine(";");
            sb.AppendLine();
        }

        sb.AppendLine("[GlobalClass]");
        sb.Append("public partial class ").Append(wrapperName).Append(" : ").Append(baseTypeName).AppendLine();
        sb.AppendLine("{");
        sb.AppendLine();
        sb.AppendLine("}");
        ctx.AddSource(wrapperName + ".g.cs", sb.ToString());
    }

    private static bool DerivesOrEquals(INamedTypeSymbol t, INamedTypeSymbol baseType)
    {
        if (SymbolEqualityComparer.Default.Equals(t, baseType)) return true;
        for (var cur = t.BaseType; cur is not null; cur = cur.BaseType)
            if (SymbolEqualityComparer.Default.Equals(cur, baseType))
                return true;
        return false;
    }
}